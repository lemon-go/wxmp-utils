{"version":3,"file":"FetchHttpClient.js","sourceRoot":"","sources":["../../src/FetchHttpClient.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\n\n// @ts-ignore: This will be removed from built files and is here to make the types available during dev work\nimport * as tough from \"@types/tough-cookie\";\n\nimport { AbortError, HttpError, TimeoutError } from \"./Errors\";\nimport { HttpClient, HttpRequest, HttpResponse } from \"./HttpClient\";\nimport { ILogger, LogLevel } from \"./ILogger\";\nimport { Platform } from \"./Utils\";\n\nexport class FetchHttpClient extends HttpClient {\n    private readonly abortControllerType: { prototype: AbortController, new(): AbortController };\n    private readonly fetchType: (input: RequestInfo, init?: RequestInit) => Promise<Response>;\n    private readonly jar?: tough.CookieJar;\n\n    private readonly logger: ILogger;\n\n    public constructor(logger: ILogger) {\n        super();\n        this.logger = logger;\n\n        if (typeof fetch === \"undefined\") {\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\n            // @ts-ignore: TS doesn't know about these names\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\n\n            // Cookies aren't automatically handled in Node so we need to add a CookieJar to preserve cookies across requests\n            this.jar = new (requireFunc(\"tough-cookie\")).CookieJar();\n            this.fetchType = requireFunc(\"node-fetch\");\n\n            // node-fetch doesn't have a nice API for getting and setting cookies\n            // fetch-cookie will wrap a fetch implementation with a default CookieJar or a provided one\n            this.fetchType = requireFunc(\"fetch-cookie\")(this.fetchType, this.jar);\n\n            // Node needs EventListener methods on AbortController which our custom polyfill doesn't provide\n            this.abortControllerType = requireFunc(\"abort-controller\");\n        } else {\n            this.fetchType = fetch.bind(self);\n            this.abortControllerType = AbortController;\n        }\n    }\n\n    /** @inheritDoc */\n    public async send(request: HttpRequest): Promise<HttpResponse> {\n        // Check that abort was not signaled before calling send\n        if (request.abortSignal && request.abortSignal.aborted) {\n            throw new AbortError();\n        }\n\n        if (!request.method) {\n            throw new Error(\"No method defined.\");\n        }\n        if (!request.url) {\n            throw new Error(\"No url defined.\");\n        }\n\n        const abortController = new this.abortControllerType();\n\n        let error: any;\n        // Hook our abortSignal into the abort controller\n        if (request.abortSignal) {\n            request.abortSignal.onabort = () => {\n                abortController.abort();\n                error = new AbortError();\n            };\n        }\n\n        // If a timeout has been passed in, setup a timeout to call abort\n        // Type needs to be any to fit window.setTimeout and NodeJS.setTimeout\n        let timeoutId: any = null;\n        if (request.timeout) {\n            const msTimeout = request.timeout!;\n            timeoutId = setTimeout(() => {\n                abortController.abort();\n                this.logger.log(LogLevel.Warning, `Timeout from HTTP request.`);\n                error = new TimeoutError();\n            }, msTimeout);\n        }\n\n        let response: Response;\n        try {\n            response = await this.fetchType(request.url!, {\n                body: request.content!,\n                cache: \"no-cache\",\n                credentials: request.withCredentials === true ? \"include\" : \"same-origin\",\n                headers: {\n                    \"Content-Type\": \"text/plain;charset=UTF-8\",\n                    \"X-Requested-With\": \"XMLHttpRequest\",\n                    ...request.headers,\n                },\n                method: request.method!,\n                mode: \"cors\",\n                redirect: \"manual\",\n                signal: abortController.signal,\n            });\n        } catch (e) {\n            if (error) {\n                throw error;\n            }\n            this.logger.log(\n                LogLevel.Warning,\n                `Error from HTTP request. ${e}.`,\n            );\n            throw e;\n        } finally {\n            if (timeoutId) {\n                clearTimeout(timeoutId);\n            }\n            if (request.abortSignal) {\n                request.abortSignal.onabort = null;\n            }\n        }\n\n        if (!response.ok) {\n            throw new HttpError(response.statusText, response.status);\n        }\n\n        const content = deserializeContent(response, request.responseType);\n        const payload = await content;\n\n        return new HttpResponse(\n            response.status,\n            response.statusText,\n            payload,\n        );\n    }\n\n    public getCookieString(url: string): string {\n        let cookies: string = \"\";\n        if (Platform.isNode && this.jar) {\n            // @ts-ignore: unused variable\n            this.jar.getCookies(url, (e, c) => cookies = c.join(\"; \"));\n        }\n        return cookies;\n    }\n}\n\nfunction deserializeContent(response: Response, responseType?: XMLHttpRequestResponseType): Promise<string | ArrayBuffer> {\n    let content;\n    switch (responseType) {\n        case \"arraybuffer\":\n            content = response.arrayBuffer();\n            break;\n        case \"text\":\n            content = response.text();\n            break;\n        case \"blob\":\n        case \"document\":\n        case \"json\":\n            throw new Error(`${responseType} is not supported.`);\n        default:\n            content = response.text();\n            break;\n    }\n\n    return content;\n}\n"]}