{"version":3,"file":"HubConnection.js","sourceRoot":"","sources":["../../src/HubConnection.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\n\nimport { HandshakeProtocol, HandshakeRequestMessage, HandshakeResponseMessage } from \"./HandshakeProtocol\";\nimport { IConnection } from \"./IConnection\";\nimport { CancelInvocationMessage, CompletionMessage, IHubProtocol, InvocationMessage, MessageType, StreamInvocationMessage, StreamItemMessage } from \"./IHubProtocol\";\nimport { ILogger, LogLevel } from \"./ILogger\";\nimport { IRetryPolicy } from \"./IRetryPolicy\";\nimport { IStreamResult } from \"./Stream\";\nimport { Subject } from \"./Subject\";\nimport { Arg } from \"./Utils\";\n\nconst DEFAULT_TIMEOUT_IN_MS: number = 30 * 1000;\nconst DEFAULT_PING_INTERVAL_IN_MS: number = 15 * 1000;\n\n/** Describes the current state of the {@link HubConnection} to the server. */\nexport enum HubConnectionState {\n    /** The hub connection is disconnected. */\n    Disconnected = \"Disconnected\",\n    /** The hub connection is connecting. */\n    Connecting = \"Connecting\",\n    /** The hub connection is connected. */\n    Connected = \"Connected\",\n    /** The hub connection is disconnecting. */\n    Disconnecting = \"Disconnecting\",\n    /** The hub connection is reconnecting. */\n    Reconnecting = \"Reconnecting\",\n}\n\n/** Represents a connection to a SignalR Hub. */\nexport class HubConnection {\n    private readonly cachedPingMessage: string | ArrayBuffer;\n    private readonly connection: IConnection;\n    private readonly logger: ILogger;\n    private readonly reconnectPolicy?: IRetryPolicy;\n    private protocol: IHubProtocol;\n    private handshakeProtocol: HandshakeProtocol;\n    private callbacks: { [invocationId: string]: (invocationEvent: StreamItemMessage | CompletionMessage | null, error?: Error) => void };\n    private methods: { [name: string]: Array<(...args: any[]) => void> };\n    private invocationId: number;\n\n    private closedCallbacks: Array<(error?: Error) => void>;\n    private reconnectingCallbacks: Array<(error?: Error) => void>;\n    private reconnectedCallbacks: Array<(connectionId?: string) => void>;\n\n    private receivedHandshakeResponse: boolean;\n    private handshakeResolver!: (value?: PromiseLike<{}>) => void;\n    private handshakeRejecter!: (reason?: any) => void;\n    private stopDuringStartError?: Error;\n\n    private connectionState: HubConnectionState;\n    // connectionStarted is tracked independently from connectionState, so we can check if the\n    // connection ever did successfully transition from connecting to connected before disconnecting.\n    private connectionStarted: boolean;\n    private startPromise?: Promise<void>;\n    private stopPromise?: Promise<void>;\n\n    // The type of these a) doesn't matter and b) varies when building in browser and node contexts\n    // Since we're building the WebPack bundle directly from the TypeScript, this matters (previously\n    // we built the bundle from the compiled JavaScript).\n    private reconnectDelayHandle?: any;\n    private timeoutHandle?: any;\n    private pingServerHandle?: any;\n\n    /** The server timeout in milliseconds.\n     *\n     * If this timeout elapses without receiving any messages from the server, the connection will be terminated with an error.\n     * The default timeout value is 30,000 milliseconds (30 seconds).\n     */\n    public serverTimeoutInMilliseconds: number;\n\n    /** Default interval at which to ping the server.\n     *\n     * The default value is 15,000 milliseconds (15 seconds).\n     * Allows the server to detect hard disconnects (like when a client unplugs their computer).\n     */\n    public keepAliveIntervalInMilliseconds: number;\n\n    /** @internal */\n    // Using a public static factory method means we can have a private constructor and an _internal_\n    // create method that can be used by HubConnectionBuilder. An \"internal\" constructor would just\n    // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a\n    // public parameter-less constructor.\n    public static create(connection: IConnection, logger: ILogger, protocol: IHubProtocol, reconnectPolicy?: IRetryPolicy): HubConnection {\n        return new HubConnection(connection, logger, protocol, reconnectPolicy);\n    }\n\n    private constructor(connection: IConnection, logger: ILogger, protocol: IHubProtocol, reconnectPolicy?: IRetryPolicy) {\n        Arg.isRequired(connection, \"connection\");\n        Arg.isRequired(logger, \"logger\");\n        Arg.isRequired(protocol, \"protocol\");\n\n        this.serverTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MS;\n        this.keepAliveIntervalInMilliseconds = DEFAULT_PING_INTERVAL_IN_MS;\n\n        this.logger = logger;\n        this.protocol = protocol;\n        this.connection = connection;\n        this.reconnectPolicy = reconnectPolicy;\n        this.handshakeProtocol = new HandshakeProtocol();\n\n        this.connection.onreceive = (data: any) => this.processIncomingData(data);\n        this.connection.onclose = (error?: Error) => this.connectionClosed(error);\n\n        this.callbacks = {};\n        this.methods = {};\n        this.closedCallbacks = [];\n        this.reconnectingCallbacks = [];\n        this.reconnectedCallbacks = [];\n        this.invocationId = 0;\n        this.receivedHandshakeResponse = false;\n        this.connectionState = HubConnectionState.Disconnected;\n        this.connectionStarted = false;\n\n        this.cachedPingMessage = this.protocol.writeMessage({ type: MessageType.Ping });\n    }\n\n    /** Indicates the state of the {@link HubConnection} to the server. */\n    get state(): HubConnectionState {\n        return this.connectionState;\n    }\n\n    /** Represents the connection id of the {@link HubConnection} on the server. The connection id will be null when the connection is either\n     *  in the disconnected state or if the negotiation step was skipped.\n     */\n    get connectionId(): string | null {\n        return this.connection ? (this.connection.connectionId || null) : null;\n    }\n\n    /** Indicates the url of the {@link HubConnection} to the server. */\n    get baseUrl(): string {\n        return this.connection.baseUrl || \"\";\n    }\n\n    /**\n     * Sets a new url for the HubConnection. Note that the url can only be changed when the connection is in either the Disconnected or\n     * Reconnecting states.\n     * @param {string} url The url to connect to.\n     */\n    set baseUrl(url: string) {\n        if (this.connectionState !== HubConnectionState.Disconnected && this.connectionState !== HubConnectionState.Reconnecting) {\n            throw new Error(\"The HubConnection must be in the Disconnected or Reconnecting state to change the url.\");\n        }\n\n        if (!url) {\n            throw new Error(\"The HubConnection url must be a valid url.\");\n        }\n\n        this.connection.baseUrl = url;\n    }\n\n    /** Starts the connection.\n     *\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.\n     */\n    public start(): Promise<void> {\n        this.startPromise = this.startWithStateTransitions();\n        return this.startPromise;\n    }\n\n    private async startWithStateTransitions(): Promise<void> {\n        if (this.connectionState !== HubConnectionState.Disconnected) {\n            return Promise.reject(new Error(\"Cannot start a HubConnection that is not in the 'Disconnected' state.\"));\n        }\n\n        this.connectionState = HubConnectionState.Connecting;\n        this.logger.log(LogLevel.Debug, \"Starting HubConnection.\");\n\n        try {\n            await this.startInternal();\n\n            this.connectionState = HubConnectionState.Connected;\n            this.connectionStarted = true;\n            this.logger.log(LogLevel.Debug, \"HubConnection connected successfully.\");\n        } catch (e) {\n            this.connectionState = HubConnectionState.Disconnected;\n            this.logger.log(LogLevel.Debug, `HubConnection failed to start successfully because of error '${e}'.`);\n            return Promise.reject(e);\n        }\n    }\n\n    private async startInternal() {\n        this.stopDuringStartError = undefined;\n        this.receivedHandshakeResponse = false;\n        // Set up the promise before any connection is (re)started otherwise it could race with received messages\n        const handshakePromise = new Promise((resolve, reject) => {\n            this.handshakeResolver = resolve;\n            this.handshakeRejecter = reject;\n        });\n\n        await this.connection.start(this.protocol.transferFormat);\n\n        try {\n            const handshakeRequest: HandshakeRequestMessage = {\n                protocol: this.protocol.name,\n                version: this.protocol.version,\n            };\n\n            this.logger.log(LogLevel.Debug, \"Sending handshake request.\");\n\n            await this.sendMessage(this.handshakeProtocol.writeHandshakeRequest(handshakeRequest));\n\n            this.logger.log(LogLevel.Information, `Using HubProtocol '${this.protocol.name}'.`);\n\n            // defensively cleanup timeout in case we receive a message from the server before we finish start\n            this.cleanupTimeout();\n            this.resetTimeoutPeriod();\n            this.resetKeepAliveInterval();\n\n            await handshakePromise;\n\n            // It's important to check the stopDuringStartError instead of just relying on the handshakePromise\n            // being rejected on close, because this continuation can run after both the handshake completed successfully\n            // and the connection was closed.\n            if (this.stopDuringStartError) {\n                // It's important to throw instead of returning a rejected promise, because we don't want to allow any state\n                // transitions to occur between now and the calling code observing the exceptions. Returning a rejected promise\n                // will cause the calling continuation to get scheduled to run later.\n                throw this.stopDuringStartError;\n            }\n        } catch (e) {\n            this.logger.log(LogLevel.Debug, `Hub handshake failed with error '${e}' during start(). Stopping HubConnection.`);\n\n            this.cleanupTimeout();\n            this.cleanupPingTimer();\n\n            // HttpConnection.stop() should not complete until after the onclose callback is invoked.\n            // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.\n            await this.connection.stop(e);\n            throw e;\n        }\n    }\n\n    /** Stops the connection.\n     *\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.\n     */\n    public async stop(): Promise<void> {\n        // Capture the start promise before the connection might be restarted in an onclose callback.\n        const startPromise = this.startPromise;\n\n        this.stopPromise = this.stopInternal();\n        await this.stopPromise;\n\n        try {\n            // Awaiting undefined continues immediately\n            await startPromise;\n        } catch (e) {\n            // This exception is returned to the user as a rejected Promise from the start method.\n        }\n    }\n\n    private stopInternal(error?: Error): Promise<void> {\n        if (this.connectionState === HubConnectionState.Disconnected) {\n            this.logger.log(LogLevel.Debug, `Call to HubConnection.stop(${error}) ignored because it is already in the disconnected state.`);\n            return Promise.resolve();\n        }\n\n        if (this.connectionState === HubConnectionState.Disconnecting) {\n            this.logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`);\n            return this.stopPromise!;\n        }\n\n        this.connectionState = HubConnectionState.Disconnecting;\n\n        this.logger.log(LogLevel.Debug, \"Stopping HubConnection.\");\n\n        if (this.reconnectDelayHandle) {\n            // We're in a reconnect delay which means the underlying connection is currently already stopped.\n            // Just clear the handle to stop the reconnect loop (which no one is waiting on thankfully) and\n            // fire the onclose callbacks.\n            this.logger.log(LogLevel.Debug, \"Connection stopped during reconnect delay. Done reconnecting.\");\n\n            clearTimeout(this.reconnectDelayHandle);\n            this.reconnectDelayHandle = undefined;\n\n            this.completeClose();\n            return Promise.resolve();\n        }\n\n        this.cleanupTimeout();\n        this.cleanupPingTimer();\n        this.stopDuringStartError = error || new Error(\"The connection was stopped before the hub handshake could complete.\");\n\n        // HttpConnection.stop() should not complete until after either HttpConnection.start() fails\n        // or the onclose callback is invoked. The onclose callback will transition the HubConnection\n        // to the disconnected state if need be before HttpConnection.stop() completes.\n        return this.connection.stop(error);\n    }\n\n    /** Invokes a streaming hub method on the server using the specified name and arguments.\n     *\n     * @typeparam T The type of the items returned by the server.\n     * @param {string} methodName The name of the server method to invoke.\n     * @param {any[]} args The arguments used to invoke the server method.\n     * @returns {IStreamResult<T>} An object that yields results from the server as they are received.\n     */\n    public stream<T = any>(methodName: string, ...args: any[]): IStreamResult<T> {\n        const [streams, streamIds] = this.replaceStreamingParams(args);\n        const invocationDescriptor = this.createStreamInvocation(methodName, args, streamIds);\n\n        let promiseQueue: Promise<void>;\n        const subject = new Subject<T>();\n        subject.cancelCallback = () => {\n            const cancelInvocation: CancelInvocationMessage = this.createCancelInvocation(invocationDescriptor.invocationId);\n\n            delete this.callbacks[invocationDescriptor.invocationId];\n\n            return promiseQueue.then(() => {\n                return this.sendWithProtocol(cancelInvocation);\n            });\n        };\n\n        this.callbacks[invocationDescriptor.invocationId] = (invocationEvent: CompletionMessage | StreamItemMessage | null, error?: Error) => {\n            if (error) {\n                subject.error(error);\n                return;\n            } else if (invocationEvent) {\n                // invocationEvent will not be null when an error is not passed to the callback\n                if (invocationEvent.type === MessageType.Completion) {\n                    if (invocationEvent.error) {\n                        subject.error(new Error(invocationEvent.error));\n                    } else {\n                        subject.complete();\n                    }\n                } else {\n                    subject.next((invocationEvent.item) as T);\n                }\n            }\n        };\n\n        promiseQueue = this.sendWithProtocol(invocationDescriptor)\n            .catch((e) => {\n                subject.error(e);\n                delete this.callbacks[invocationDescriptor.invocationId];\n            });\n\n        this.launchStreams(streams, promiseQueue);\n\n        return subject;\n    }\n\n    private sendMessage(message: any) {\n        this.resetKeepAliveInterval();\n        return this.connection.send(message);\n    }\n\n    /**\n     * Sends a js object to the server.\n     * @param message The js object to serialize and send.\n     */\n    private sendWithProtocol(message: any) {\n        return this.sendMessage(this.protocol.writeMessage(message));\n    }\n\n    /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.\n     *\n     * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still\n     * be processing the invocation.\n     *\n     * @param {string} methodName The name of the server method to invoke.\n     * @param {any[]} args The arguments used to invoke the server method.\n     * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.\n     */\n    public send(methodName: string, ...args: any[]): Promise<void> {\n        const [streams, streamIds] = this.replaceStreamingParams(args);\n        const sendPromise = this.sendWithProtocol(this.createInvocation(methodName, args, true, streamIds));\n\n        this.launchStreams(streams, sendPromise);\n\n        return sendPromise;\n    }\n\n    /** Invokes a hub method on the server using the specified name and arguments.\n     *\n     * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise\n     * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of\n     * resolving the Promise.\n     *\n     * @typeparam T The expected return type.\n     * @param {string} methodName The name of the server method to invoke.\n     * @param {any[]} args The arguments used to invoke the server method.\n     * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.\n     */\n    public invoke<T = any>(methodName: string, ...args: any[]): Promise<T> {\n        const [streams, streamIds] = this.replaceStreamingParams(args);\n        const invocationDescriptor = this.createInvocation(methodName, args, false, streamIds);\n\n        const p = new Promise<any>((resolve, reject) => {\n            // invocationId will always have a value for a non-blocking invocation\n            this.callbacks[invocationDescriptor.invocationId!] = (invocationEvent: StreamItemMessage | CompletionMessage | null, error?: Error) => {\n                if (error) {\n                    reject(error);\n                    return;\n                } else if (invocationEvent) {\n                    // invocationEvent will not be null when an error is not passed to the callback\n                    if (invocationEvent.type === MessageType.Completion) {\n                        if (invocationEvent.error) {\n                            reject(new Error(invocationEvent.error));\n                        } else {\n                            resolve(invocationEvent.result);\n                        }\n                    } else {\n                        reject(new Error(`Unexpected message type: ${invocationEvent.type}`));\n                    }\n                }\n            };\n\n            const promiseQueue = this.sendWithProtocol(invocationDescriptor)\n                .catch((e) => {\n                    reject(e);\n                    // invocationId will always have a value for a non-blocking invocation\n                    delete this.callbacks[invocationDescriptor.invocationId!];\n                });\n\n            this.launchStreams(streams, promiseQueue);\n        });\n\n        return p;\n    }\n\n    /** Registers a handler that will be invoked when the hub method with the specified method name is invoked.\n     *\n     * @param {string} methodName The name of the hub method to define.\n     * @param {Function} newMethod The handler that will be raised when the hub method is invoked.\n     */\n    public on(methodName: string, newMethod: (...args: any[]) => void) {\n        if (!methodName || !newMethod) {\n            return;\n        }\n\n        methodName = methodName.toLowerCase();\n        if (!this.methods[methodName]) {\n            this.methods[methodName] = [];\n        }\n\n        // Preventing adding the same handler multiple times.\n        if (this.methods[methodName].indexOf(newMethod) !== -1) {\n            return;\n        }\n\n        this.methods[methodName].push(newMethod);\n    }\n\n    /** Removes all handlers for the specified hub method.\n     *\n     * @param {string} methodName The name of the method to remove handlers for.\n     */\n    public off(methodName: string): void;\n\n    /** Removes the specified handler for the specified hub method.\n     *\n     * You must pass the exact same Function instance as was previously passed to {@link @microsoft/signalr.HubConnection.on}. Passing a different instance (even if the function\n     * body is the same) will not remove the handler.\n     *\n     * @param {string} methodName The name of the method to remove handlers for.\n     * @param {Function} method The handler to remove. This must be the same Function instance as the one passed to {@link @microsoft/signalr.HubConnection.on}.\n     */\n    public off(methodName: string, method: (...args: any[]) => void): void;\n    public off(methodName: string, method?: (...args: any[]) => void): void {\n        if (!methodName) {\n            return;\n        }\n\n        methodName = methodName.toLowerCase();\n        const handlers = this.methods[methodName];\n        if (!handlers) {\n            return;\n        }\n        if (method) {\n            const removeIdx = handlers.indexOf(method);\n            if (removeIdx !== -1) {\n                handlers.splice(removeIdx, 1);\n                if (handlers.length === 0) {\n                    delete this.methods[methodName];\n                }\n            }\n        } else {\n            delete this.methods[methodName];\n        }\n\n    }\n\n    /** Registers a handler that will be invoked when the connection is closed.\n     *\n     * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).\n     */\n    public onclose(callback: (error?: Error) => void) {\n        if (callback) {\n            this.closedCallbacks.push(callback);\n        }\n    }\n\n    /** Registers a handler that will be invoked when the connection starts reconnecting.\n     *\n     * @param {Function} callback The handler that will be invoked when the connection starts reconnecting. Optionally receives a single argument containing the error that caused the connection to start reconnecting (if any).\n     */\n    public onreconnecting(callback: (error?: Error) => void) {\n        if (callback) {\n            this.reconnectingCallbacks.push(callback);\n        }\n    }\n\n    /** Registers a handler that will be invoked when the connection successfully reconnects.\n     *\n     * @param {Function} callback The handler that will be invoked when the connection successfully reconnects.\n     */\n    public onreconnected(callback: (connectionId?: string) => void) {\n        if (callback) {\n            this.reconnectedCallbacks.push(callback);\n        }\n    }\n\n    private processIncomingData(data: any) {\n        this.cleanupTimeout();\n\n        if (!this.receivedHandshakeResponse) {\n            data = this.processHandshakeResponse(data);\n            this.receivedHandshakeResponse = true;\n        }\n\n        // Data may have all been read when processing handshake response\n        if (data) {\n            // Parse the messages\n            const messages = this.protocol.parseMessages(data, this.logger);\n\n            for (const message of messages) {\n                switch (message.type) {\n                    case MessageType.Invocation:\n                        this.invokeClientMethod(message);\n                        break;\n                    case MessageType.StreamItem:\n                    case MessageType.Completion:\n                        const callback = this.callbacks[message.invocationId];\n                        if (callback) {\n                            if (message.type === MessageType.Completion) {\n                                delete this.callbacks[message.invocationId];\n                            }\n                            callback(message);\n                        }\n                        break;\n                    case MessageType.Ping:\n                        // Don't care about pings\n                        break;\n                    case MessageType.Close:\n                        this.logger.log(LogLevel.Information, \"Close message received from server.\");\n\n                        const error = message.error ? new Error(\"Server returned an error on close: \" + message.error) : undefined;\n\n                        if (message.allowReconnect === true) {\n                            // It feels wrong not to await connection.stop() here, but processIncomingData is called as part of an onreceive callback which is not async,\n                            // this is already the behavior for serverTimeout(), and HttpConnection.Stop() should catch and log all possible exceptions.\n\n                            // tslint:disable-next-line:no-floating-promises\n                            this.connection.stop(error);\n                        } else {\n                            // We cannot await stopInternal() here, but subsequent calls to stop() will await this if stopInternal() is still ongoing.\n                            this.stopPromise = this.stopInternal(error);\n                        }\n\n                        break;\n                    default:\n                        this.logger.log(LogLevel.Warning, `Invalid message type: ${message.type}.`);\n                        break;\n                }\n            }\n        }\n\n        this.resetTimeoutPeriod();\n    }\n\n    private processHandshakeResponse(data: any): any {\n        let responseMessage: HandshakeResponseMessage;\n        let remainingData: any;\n\n        try {\n            [remainingData, responseMessage] = this.handshakeProtocol.parseHandshakeResponse(data);\n        } catch (e) {\n            const message = \"Error parsing handshake response: \" + e;\n            this.logger.log(LogLevel.Error, message);\n\n            const error = new Error(message);\n            this.handshakeRejecter(error);\n            throw error;\n        }\n        if (responseMessage.error) {\n            const message = \"Server returned handshake error: \" + responseMessage.error;\n            this.logger.log(LogLevel.Error, message);\n\n            const error = new Error(message);\n            this.handshakeRejecter(error);\n            throw error;\n        } else {\n            this.logger.log(LogLevel.Debug, \"Server handshake complete.\");\n        }\n\n        this.handshakeResolver();\n        return remainingData;\n    }\n\n    private resetKeepAliveInterval() {\n        if (this.connection.features.inherentKeepAlive) {\n            return;\n        }\n\n        this.cleanupPingTimer();\n        this.pingServerHandle = setTimeout(async () => {\n            if (this.connectionState === HubConnectionState.Connected) {\n                try {\n                    await this.sendMessage(this.cachedPingMessage);\n                } catch {\n                    // We don't care about the error. It should be seen elsewhere in the client.\n                    // The connection is probably in a bad or closed state now, cleanup the timer so it stops triggering\n                    this.cleanupPingTimer();\n                }\n            }\n        }, this.keepAliveIntervalInMilliseconds);\n    }\n\n    private resetTimeoutPeriod() {\n        if (!this.connection.features || !this.connection.features.inherentKeepAlive) {\n            // Set the timeout timer\n            this.timeoutHandle = setTimeout(() => this.serverTimeout(), this.serverTimeoutInMilliseconds);\n        }\n    }\n\n    private serverTimeout() {\n        // The server hasn't talked to us in a while. It doesn't like us anymore ... :(\n        // Terminate the connection, but we don't need to wait on the promise. This could trigger reconnecting.\n        // tslint:disable-next-line:no-floating-promises\n        this.connection.stop(new Error(\"Server timeout elapsed without receiving a message from the server.\"));\n    }\n\n    private invokeClientMethod(invocationMessage: InvocationMessage) {\n        const methods = this.methods[invocationMessage.target.toLowerCase()];\n        if (methods) {\n            try {\n                methods.forEach((m) => m.apply(this, invocationMessage.arguments));\n            } catch (e) {\n                this.logger.log(LogLevel.Error, `A callback for the method ${invocationMessage.target.toLowerCase()} threw error '${e}'.`);\n            }\n\n            if (invocationMessage.invocationId) {\n                // This is not supported in v1. So we return an error to avoid blocking the server waiting for the response.\n                const message = \"Server requested a response, which is not supported in this version of the client.\";\n                this.logger.log(LogLevel.Error, message);\n\n                // We don't want to wait on the stop itself.\n                this.stopPromise = this.stopInternal(new Error(message));\n            }\n        } else {\n            this.logger.log(LogLevel.Warning, `No client method with the name '${invocationMessage.target}' found.`);\n        }\n    }\n\n    private connectionClosed(error?: Error) {\n        this.logger.log(LogLevel.Debug, `HubConnection.connectionClosed(${error}) called while in state ${this.connectionState}.`);\n\n        // Triggering this.handshakeRejecter is insufficient because it could already be resolved without the continuation having run yet.\n        this.stopDuringStartError = this.stopDuringStartError || error || new Error(\"The underlying connection was closed before the hub handshake could complete.\");\n\n        // If the handshake is in progress, start will be waiting for the handshake promise, so we complete it.\n        // If it has already completed, this should just noop.\n        if (this.handshakeResolver) {\n            this.handshakeResolver();\n        }\n\n        this.cancelCallbacksWithError(error || new Error(\"Invocation canceled due to the underlying connection being closed.\"));\n\n        this.cleanupTimeout();\n        this.cleanupPingTimer();\n\n        if (this.connectionState === HubConnectionState.Disconnecting) {\n            this.completeClose(error);\n        } else if (this.connectionState === HubConnectionState.Connected && this.reconnectPolicy) {\n            // tslint:disable-next-line:no-floating-promises\n            this.reconnect(error);\n        } else if (this.connectionState === HubConnectionState.Connected) {\n            this.completeClose(error);\n        }\n\n        // If none of the above if conditions were true were called the HubConnection must be in either:\n        // 1. The Connecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail it.\n        // 2. The Reconnecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail the current reconnect attempt\n        //    and potentially continue the reconnect() loop.\n        // 3. The Disconnected state in which case we're already done.\n    }\n\n    private completeClose(error?: Error) {\n        if (this.connectionStarted) {\n            this.connectionState = HubConnectionState.Disconnected;\n            this.connectionStarted = false;\n\n            try {\n                this.closedCallbacks.forEach((c) => c.apply(this, [error]));\n            } catch (e) {\n                this.logger.log(LogLevel.Error, `An onclose callback called with error '${error}' threw error '${e}'.`);\n            }\n        }\n    }\n\n    private async reconnect(error?: Error) {\n        const reconnectStartTime = Date.now();\n        let previousReconnectAttempts = 0;\n        let retryError = error !== undefined ? error : new Error(\"Attempting to reconnect due to a unknown error.\");\n\n        let nextRetryDelay = this.getNextRetryDelay(previousReconnectAttempts++, 0, retryError);\n\n        if (nextRetryDelay === null) {\n            this.logger.log(LogLevel.Debug, \"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt.\");\n            this.completeClose(error);\n            return;\n        }\n\n        this.connectionState = HubConnectionState.Reconnecting;\n\n        if (error) {\n            this.logger.log(LogLevel.Information, `Connection reconnecting because of error '${error}'.`);\n        } else {\n            this.logger.log(LogLevel.Information, \"Connection reconnecting.\");\n        }\n\n        if (this.onreconnecting) {\n            try {\n                this.reconnectingCallbacks.forEach((c) => c.apply(this, [error]));\n            } catch (e) {\n                this.logger.log(LogLevel.Error, `An onreconnecting callback called with error '${error}' threw error '${e}'.`);\n            }\n\n            // Exit early if an onreconnecting callback called connection.stop().\n            if (this.connectionState !== HubConnectionState.Reconnecting) {\n                this.logger.log(LogLevel.Debug, \"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.\");\n                return;\n            }\n        }\n\n        while (nextRetryDelay !== null) {\n            this.logger.log(LogLevel.Information, `Reconnect attempt number ${previousReconnectAttempts} will start in ${nextRetryDelay} ms.`);\n\n            await new Promise((resolve) => {\n                this.reconnectDelayHandle = setTimeout(resolve, nextRetryDelay!);\n            });\n            this.reconnectDelayHandle = undefined;\n\n            if (this.connectionState !== HubConnectionState.Reconnecting) {\n                this.logger.log(LogLevel.Debug, \"Connection left the reconnecting state during reconnect delay. Done reconnecting.\");\n                return;\n            }\n\n            try {\n                await this.startInternal();\n\n                this.connectionState = HubConnectionState.Connected;\n                this.logger.log(LogLevel.Information, \"HubConnection reconnected successfully.\");\n\n                if (this.onreconnected) {\n                    try {\n                        this.reconnectedCallbacks.forEach((c) => c.apply(this, [this.connection.connectionId]));\n                    } catch (e) {\n                        this.logger.log(LogLevel.Error, `An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${e}'.`);\n                    }\n                }\n\n                return;\n            } catch (e) {\n                this.logger.log(LogLevel.Information, `Reconnect attempt failed because of error '${e}'.`);\n\n                if (this.connectionState !== HubConnectionState.Reconnecting) {\n                    this.logger.log(LogLevel.Debug, \"Connection left the reconnecting state during reconnect attempt. Done reconnecting.\");\n                    return;\n                }\n\n                retryError = e instanceof Error ? e : new Error(e.toString());\n                nextRetryDelay = this.getNextRetryDelay(previousReconnectAttempts++, Date.now() - reconnectStartTime, retryError);\n            }\n        }\n\n        this.logger.log(LogLevel.Information, `Reconnect retries have been exhausted after ${Date.now() - reconnectStartTime} ms and ${previousReconnectAttempts} failed attempts. Connection disconnecting.`);\n\n        this.completeClose();\n    }\n\n    private getNextRetryDelay(previousRetryCount: number, elapsedMilliseconds: number, retryReason: Error) {\n        try {\n            return this.reconnectPolicy!.nextRetryDelayInMilliseconds({\n                elapsedMilliseconds,\n                previousRetryCount,\n                retryReason,\n            });\n        } catch (e) {\n            this.logger.log(LogLevel.Error, `IRetryPolicy.nextRetryDelayInMilliseconds(${previousRetryCount}, ${elapsedMilliseconds}) threw error '${e}'.`);\n            return null;\n        }\n    }\n\n    private cancelCallbacksWithError(error: Error) {\n        const callbacks = this.callbacks;\n        this.callbacks = {};\n\n        Object.keys(callbacks)\n            .forEach((key) => {\n                const callback = callbacks[key];\n                callback(null, error);\n            });\n    }\n\n    private cleanupPingTimer(): void {\n        if (this.pingServerHandle) {\n            clearTimeout(this.pingServerHandle);\n        }\n    }\n\n    private cleanupTimeout(): void {\n        if (this.timeoutHandle) {\n            clearTimeout(this.timeoutHandle);\n        }\n    }\n\n    private createInvocation(methodName: string, args: any[], nonblocking: boolean, streamIds: string[]): InvocationMessage {\n        if (nonblocking) {\n            if (streamIds.length !== 0) {\n                return {\n                    arguments: args,\n                    streamIds,\n                    target: methodName,\n                    type: MessageType.Invocation,\n                };\n            } else {\n                return {\n                    arguments: args,\n                    target: methodName,\n                    type: MessageType.Invocation,\n                };\n            }\n        } else {\n            const invocationId = this.invocationId;\n            this.invocationId++;\n\n            if (streamIds.length !== 0) {\n                return {\n                    arguments: args,\n                    invocationId: invocationId.toString(),\n                    streamIds,\n                    target: methodName,\n                    type: MessageType.Invocation,\n                };\n            } else {\n                return {\n                    arguments: args,\n                    invocationId: invocationId.toString(),\n                    target: methodName,\n                    type: MessageType.Invocation,\n                };\n            }\n        }\n    }\n\n    private launchStreams(streams: Array<IStreamResult<any>>, promiseQueue: Promise<void>): void {\n        if (streams.length === 0) {\n            return;\n        }\n\n        // Synchronize stream data so they arrive in-order on the server\n        if (!promiseQueue) {\n            promiseQueue = Promise.resolve();\n        }\n\n        // We want to iterate over the keys, since the keys are the stream ids\n        // tslint:disable-next-line:forin\n        for (const streamId in streams) {\n            streams[streamId].subscribe({\n                complete: () => {\n                    promiseQueue = promiseQueue.then(() => this.sendWithProtocol(this.createCompletionMessage(streamId)));\n                },\n                error: (err) => {\n                    let message: string;\n                    if (err instanceof Error) {\n                        message = err.message;\n                    } else if (err && err.toString) {\n                        message = err.toString();\n                    } else {\n                        message = \"Unknown error\";\n                    }\n\n                    promiseQueue = promiseQueue.then(() => this.sendWithProtocol(this.createCompletionMessage(streamId, message)));\n                },\n                next: (item) => {\n                    promiseQueue = promiseQueue.then(() => this.sendWithProtocol(this.createStreamItemMessage(streamId, item)));\n                },\n            });\n        }\n    }\n\n    private replaceStreamingParams(args: any[]): [Array<IStreamResult<any>>, string[]] {\n        const streams: Array<IStreamResult<any>> = [];\n        const streamIds: string[] = [];\n        for (let i = 0; i < args.length; i++) {\n            const argument = args[i];\n            if (this.isObservable(argument)) {\n                const streamId = this.invocationId;\n                this.invocationId++;\n                // Store the stream for later use\n                streams[streamId] = argument;\n                streamIds.push(streamId.toString());\n\n                // remove stream from args\n                args.splice(i, 1);\n            }\n        }\n\n        return [streams, streamIds];\n    }\n\n    private isObservable(arg: any): arg is IStreamResult<any> {\n        // This allows other stream implementations to just work (like rxjs)\n        return arg && arg.subscribe && typeof arg.subscribe === \"function\";\n    }\n\n    private createStreamInvocation(methodName: string, args: any[], streamIds: string[]): StreamInvocationMessage {\n        const invocationId = this.invocationId;\n        this.invocationId++;\n\n        if (streamIds.length !== 0) {\n            return {\n                arguments: args,\n                invocationId: invocationId.toString(),\n                streamIds,\n                target: methodName,\n                type: MessageType.StreamInvocation,\n            };\n        } else {\n            return {\n                arguments: args,\n                invocationId: invocationId.toString(),\n                target: methodName,\n                type: MessageType.StreamInvocation,\n            };\n        }\n    }\n\n    private createCancelInvocation(id: string): CancelInvocationMessage {\n        return {\n            invocationId: id,\n            type: MessageType.CancelInvocation,\n        };\n    }\n\n    private createStreamItemMessage(id: string, item: any): StreamItemMessage {\n        return {\n            invocationId: id,\n            item,\n            type: MessageType.StreamItem,\n        };\n    }\n\n    private createCompletionMessage(id: string, error?: any, result?: any): CompletionMessage {\n        if (error) {\n            return {\n                error,\n                invocationId: id,\n                type: MessageType.Completion,\n            };\n        }\n\n        return {\n            invocationId: id,\n            result,\n            type: MessageType.Completion,\n        };\n    }\n}\n"]}