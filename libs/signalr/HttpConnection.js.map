{"version":3,"file":"HttpConnection.js","sourceRoot":"","sources":["../../src/HttpConnection.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\n\nimport { DefaultHttpClient } from \"./DefaultHttpClient\";\nimport { HttpClient } from \"./HttpClient\";\nimport { IConnection } from \"./IConnection\";\nimport { IHttpConnectionOptions } from \"./IHttpConnectionOptions\";\nimport { ILogger, LogLevel } from \"./ILogger\";\nimport { HttpTransportType, ITransport, TransferFormat } from \"./ITransport\";\nimport { LongPollingTransport } from \"./LongPollingTransport\";\nimport { ServerSentEventsTransport } from \"./ServerSentEventsTransport\";\nimport { UniWebSocket } from \"./UniWebSocket\";\nimport { Arg, createLogger, getUserAgentHeader, Platform } from \"./Utils\";\nimport { WebSocketTransport } from \"./WebSocketTransport\";\nimport { WxWebSocket } from \"./WxWebSocket\";\n\n/** @private */\nconst enum ConnectionState {\n    Connecting = \"Connecting\",\n    Connected = \"Connected\",\n    Disconnected = \"Disconnected\",\n    Disconnecting = \"Disconnecting\",\n}\n\n/** @private */\nexport interface INegotiateResponse {\n    connectionId?: string;\n    connectionToken?: string;\n    negotiateVersion?: number;\n    availableTransports?: IAvailableTransport[];\n    url?: string;\n    accessToken?: string;\n    error?: string;\n}\n\n/** @private */\nexport interface IAvailableTransport {\n    transport: keyof typeof HttpTransportType;\n    transferFormats: Array<keyof typeof TransferFormat>;\n}\n\nconst MAX_REDIRECTS = 100;\n\n/** @private */\nexport class HttpConnection implements IConnection {\n    private connectionState: ConnectionState;\n    // connectionStarted is tracked independently from connectionState, so we can check if the\n    // connection ever did successfully transition from connecting to connected before disconnecting.\n    private connectionStarted: boolean;\n    private readonly httpClient: HttpClient;\n    private readonly logger: ILogger;\n    private readonly options: IHttpConnectionOptions;\n    private transport?: ITransport;\n    private startInternalPromise?: Promise<void>;\n    private stopPromise?: Promise<void>;\n    private stopPromiseResolver!: (value?: PromiseLike<void>) => void;\n    private stopError?: Error;\n    private accessTokenFactory?: () => string | Promise<string>;\n    private sendQueue?: TransportSendQueue;\n\n    public readonly features: any = {};\n    public baseUrl: string;\n    public connectionId?: string;\n    public onreceive: ((data: string | ArrayBuffer) => void) | null;\n    public onclose: ((e?: Error) => void) | null;\n\n    private readonly negotiateVersion: number = 1;\n\n    constructor(url: string, options: IHttpConnectionOptions = {}) {\n        Arg.isRequired(url, \"url\");\n\n        this.logger = createLogger(options.logger);\n        this.baseUrl = this.resolveUrl(url);\n\n        options = options || {};\n        options.logMessageContent = options.logMessageContent === undefined ? false : options.logMessageContent;\n        if (typeof options.withCredentials === \"boolean\" || options.withCredentials === undefined) {\n            options.withCredentials = options.withCredentials === undefined ? true : options.withCredentials;\n        } else {\n            throw new Error(\"withCredentials option was not a 'boolean' or 'undefined' value\");\n        }\n\n        let webSocketModule: any = null;\n        let eventSourceModule: any = null;\n\n        if (Platform.isNode && typeof require !== \"undefined\") {\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\n            // @ts-ignore: TS doesn't know about these names\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\n            webSocketModule = requireFunc(\"ws\");\n            eventSourceModule = requireFunc(\"eventsource\");\n        }\n\n        if (Platform.isUni && !options.WebSocket) {\n            options.WebSocket = UniWebSocket;\n        } else if (Platform.isWechatMP && !options.WebSocket) {\n            options.WebSocket = WxWebSocket;\n        } else if (!Platform.isNode && typeof WebSocket !== \"undefined\" && !options.WebSocket) {\n            options.WebSocket = WebSocket;\n        } else if (Platform.isNode && !options.WebSocket) {\n            if (webSocketModule) {\n                options.WebSocket = webSocketModule;\n            }\n        }\n\n        if (!Platform.isNode && typeof EventSource !== \"undefined\" && !options.EventSource) {\n            options.EventSource = EventSource;\n        } else if (Platform.isNode && !options.EventSource) {\n            if (typeof eventSourceModule !== \"undefined\") {\n                options.EventSource = eventSourceModule;\n            }\n        }\n\n        this.httpClient = options.httpClient || new DefaultHttpClient(this.logger);\n        this.connectionState = ConnectionState.Disconnected;\n        this.connectionStarted = false;\n        this.options = options;\n\n        this.onreceive = null;\n        this.onclose = null;\n    }\n\n    public start(): Promise<void>;\n    public start(transferFormat: TransferFormat): Promise<void>;\n    public async start(transferFormat?: TransferFormat): Promise<void> {\n        transferFormat = transferFormat || TransferFormat.Binary;\n\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\n\n        this.logger.log(LogLevel.Debug, `Starting connection with transfer format '${TransferFormat[transferFormat]}'.`);\n\n        if (this.connectionState !== ConnectionState.Disconnected) {\n            return Promise.reject(new Error(\"Cannot start an HttpConnection that is not in the 'Disconnected' state.\"));\n        }\n\n        this.connectionState = ConnectionState.Connecting;\n\n        this.startInternalPromise = this.startInternal(transferFormat);\n        await this.startInternalPromise;\n\n        // The TypeScript compiler thinks that connectionState must be Connecting here. The TypeScript compiler is wrong.\n        if (this.connectionState as any === ConnectionState.Disconnecting) {\n            // stop() was called and transitioned the client into the Disconnecting state.\n            const message = \"Failed to start the HttpConnection before stop() was called.\";\n            this.logger.log(LogLevel.Error, message);\n\n            // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.\n            await this.stopPromise;\n\n            return Promise.reject(new Error(message));\n        } else if (this.connectionState as any !== ConnectionState.Connected) {\n            // stop() was called and transitioned the client into the Disconnecting state.\n            const message = \"HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!\";\n            this.logger.log(LogLevel.Error, message);\n            return Promise.reject(new Error(message));\n        }\n\n        this.connectionStarted = true;\n    }\n\n    public send(data: string | ArrayBuffer): Promise<void> {\n        if (this.connectionState !== ConnectionState.Connected) {\n            return Promise.reject(new Error(\"Cannot send data if the connection is not in the 'Connected' State.\"));\n        }\n\n        if (!this.sendQueue) {\n            this.sendQueue = new TransportSendQueue(this.transport!);\n        }\n\n        // Transport will not be null if state is connected\n        return this.sendQueue.send(data);\n    }\n\n    public async stop(error?: Error): Promise<void> {\n        if (this.connectionState === ConnectionState.Disconnected) {\n            this.logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnected state.`);\n            return Promise.resolve();\n        }\n\n        if (this.connectionState === ConnectionState.Disconnecting) {\n            this.logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`);\n            return this.stopPromise;\n        }\n\n        this.connectionState = ConnectionState.Disconnecting;\n\n        this.stopPromise = new Promise((resolve) => {\n            // Don't complete stop() until stopConnection() completes.\n            this.stopPromiseResolver = resolve;\n        });\n\n        // stopInternal should never throw so just observe it.\n        await this.stopInternal(error);\n        await this.stopPromise;\n    }\n\n    private async stopInternal(error?: Error): Promise<void> {\n        // Set error as soon as possible otherwise there is a race between\n        // the transport closing and providing an error and the error from a close message\n        // We would prefer the close message error.\n        this.stopError = error;\n\n        try {\n            await this.startInternalPromise;\n        } catch (e) {\n            // This exception is returned to the user as a rejected Promise from the start method.\n        }\n\n        // The transport's onclose will trigger stopConnection which will run our onclose event.\n        // The transport should always be set if currently connected. If it wasn't set, it's likely because\n        // stop was called during start() and start() failed.\n        if (this.transport) {\n            try {\n                await this.transport.stop();\n            } catch (e) {\n                this.logger.log(LogLevel.Error, `HttpConnection.transport.stop() threw error '${e}'.`);\n                this.stopConnection();\n            }\n\n            this.transport = undefined;\n        } else {\n            this.logger.log(LogLevel.Debug, \"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.\");\n            this.stopConnection();\n        }\n    }\n\n    private async startInternal(transferFormat: TransferFormat): Promise<void> {\n        // Store the original base url and the access token factory since they may change\n        // as part of negotiating\n        let url = this.baseUrl;\n        this.accessTokenFactory = this.options.accessTokenFactory;\n\n        try {\n            if (this.options.skipNegotiation) {\n                if (this.options.transport === HttpTransportType.WebSockets) {\n                    // No need to add a connection ID in this case\n                    this.transport = this.constructTransport(HttpTransportType.WebSockets);\n                    // We should just call connect directly in this case.\n                    // No fallback or negotiate in this case.\n                    await this.startTransport(url, transferFormat);\n                } else {\n                    throw new Error(\"Negotiation can only be skipped when using the WebSocket transport directly.\");\n                }\n            } else {\n                let negotiateResponse: INegotiateResponse | null = null;\n                let redirects = 0;\n\n                do {\n                    negotiateResponse = await this.getNegotiationResponse(url);\n                    // the user tries to stop the connection when it is being started\n                    if (this.connectionState === ConnectionState.Disconnecting || this.connectionState === ConnectionState.Disconnected) {\n                        throw new Error(\"The connection was stopped during negotiation.\");\n                    }\n\n                    if (negotiateResponse.error) {\n                        throw new Error(negotiateResponse.error);\n                    }\n\n                    if ((negotiateResponse as any).ProtocolVersion) {\n                        throw new Error(\"Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.\");\n                    }\n\n                    if (negotiateResponse.url) {\n                        url = negotiateResponse.url;\n                    }\n\n                    if (negotiateResponse.accessToken) {\n                        // Replace the current access token factory with one that uses\n                        // the returned access token\n                        const accessToken = negotiateResponse.accessToken;\n                        this.accessTokenFactory = () => accessToken;\n                    }\n\n                    redirects++;\n                }\n                while (negotiateResponse.url && redirects < MAX_REDIRECTS);\n\n                if (redirects === MAX_REDIRECTS && negotiateResponse.url) {\n                    throw new Error(\"Negotiate redirection limit exceeded.\");\n                }\n\n                await this.createTransport(url, this.options.transport, negotiateResponse, transferFormat);\n            }\n\n            if (this.transport instanceof LongPollingTransport) {\n                this.features.inherentKeepAlive = true;\n            }\n\n            if (this.connectionState === ConnectionState.Connecting) {\n                // Ensure the connection transitions to the connected state prior to completing this.startInternalPromise.\n                // start() will handle the case when stop was called and startInternal exits still in the disconnecting state.\n                this.logger.log(LogLevel.Debug, \"The HttpConnection connected successfully.\");\n                this.connectionState = ConnectionState.Connected;\n            }\n\n            // stop() is waiting on us via this.startInternalPromise so keep this.transport around so it can clean up.\n            // This is the only case startInternal can exit in neither the connected nor disconnected state because stopConnection()\n            // will transition to the disconnected state. start() will wait for the transition using the stopPromise.\n        } catch (e) {\n            this.logger.log(LogLevel.Error, \"Failed to start the connection: \" + e);\n            this.connectionState = ConnectionState.Disconnected;\n            this.transport = undefined;\n            return Promise.reject(e);\n        }\n    }\n\n    private async getNegotiationResponse(url: string): Promise<INegotiateResponse> {\n        const headers = {};\n        if (this.accessTokenFactory) {\n            const token = await this.accessTokenFactory();\n            if (token) {\n                headers[`Authorization`] = `Bearer ${token}`;\n            }\n        }\n\n        const [name, value] = getUserAgentHeader();\n        headers[name] = value;\n\n        const negotiateUrl = this.resolveNegotiateUrl(url);\n        this.logger.log(LogLevel.Debug, `Sending negotiation request: ${negotiateUrl}.`);\n        try {\n            const response = await this.httpClient.post(negotiateUrl, {\n                content: \"\",\n                headers: { ...headers, ...this.options.headers },\n                withCredentials: this.options.withCredentials,\n            });\n\n            if (response.statusCode !== 200) {\n                return Promise.reject(new Error(`Unexpected status code returned from negotiate '${response.statusCode}'`));\n            }\n\n            const negotiateResponse = JSON.parse(response.content as string) as INegotiateResponse;\n            if (!negotiateResponse.negotiateVersion || negotiateResponse.negotiateVersion < 1) {\n                // Negotiate version 0 doesn't use connectionToken\n                // So we set it equal to connectionId so all our logic can use connectionToken without being aware of the negotiate version\n                negotiateResponse.connectionToken = negotiateResponse.connectionId;\n            }\n            return negotiateResponse;\n        } catch (e) {\n            this.logger.log(LogLevel.Error, \"Failed to complete negotiation with the server: \" + e);\n            return Promise.reject(e);\n        }\n    }\n\n    private createConnectUrl(url: string, connectionToken: string | null | undefined) {\n        if (!connectionToken) {\n            return url;\n        }\n\n        return url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + `id=${connectionToken}`;\n    }\n\n    private async createTransport(url: string, requestedTransport: HttpTransportType | ITransport | undefined, negotiateResponse: INegotiateResponse, requestedTransferFormat: TransferFormat): Promise<void> {\n        let connectUrl = this.createConnectUrl(url, negotiateResponse.connectionToken);\n        if (this.isITransport(requestedTransport)) {\n            this.logger.log(LogLevel.Debug, \"Connection was provided an instance of ITransport, using that directly.\");\n            this.transport = requestedTransport;\n            await this.startTransport(connectUrl, requestedTransferFormat);\n\n            this.connectionId = negotiateResponse.connectionId;\n            return;\n        }\n\n        const transportExceptions: any[] = [];\n        const transports = negotiateResponse.availableTransports || [];\n        let negotiate: INegotiateResponse | undefined = negotiateResponse;\n        for (const endpoint of transports) {\n            const transportOrError = this.resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat);\n            if (transportOrError instanceof Error) {\n                // Store the error and continue, we don't want to cause a re-negotiate in these cases\n                transportExceptions.push(`${endpoint.transport} failed: ${transportOrError}`);\n            } else if (this.isITransport(transportOrError)) {\n                this.transport = transportOrError;\n                if (!negotiate) {\n                    try {\n                        negotiate = await this.getNegotiationResponse(url);\n                    } catch (ex) {\n                        return Promise.reject(ex);\n                    }\n                    connectUrl = this.createConnectUrl(url, negotiate.connectionToken);\n                }\n                try {\n                    await this.startTransport(connectUrl, requestedTransferFormat);\n                    this.connectionId = negotiate.connectionId;\n                    return;\n                } catch (ex) {\n                    this.logger.log(LogLevel.Error, `Failed to start the transport '${endpoint.transport}': ${ex}`);\n                    negotiate = undefined;\n                    transportExceptions.push(`${endpoint.transport} failed: ${ex}`);\n\n                    if (this.connectionState !== ConnectionState.Connecting) {\n                        const message = \"Failed to select transport before stop() was called.\";\n                        this.logger.log(LogLevel.Debug, message);\n                        return Promise.reject(new Error(message));\n                    }\n                }\n            }\n        }\n\n        if (transportExceptions.length > 0) {\n            return Promise.reject(new Error(`Unable to connect to the server with any of the available transports. ${transportExceptions.join(\" \")}`));\n        }\n        return Promise.reject(new Error(\"None of the transports supported by the client are supported by the server.\"));\n    }\n\n    private constructTransport(transport: HttpTransportType): ITransport {\n        switch (transport) {\n            case HttpTransportType.WebSockets:\n                if (!this.options.WebSocket) {\n                    throw new Error(\"'WebSocket' is not supported in your environment.\");\n                }\n                return new WebSocketTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.WebSocket, this.options.headers || {});\n            case HttpTransportType.ServerSentEvents:\n                if (!this.options.EventSource) {\n                    throw new Error(\"'EventSource' is not supported in your environment.\");\n                }\n                return new ServerSentEventsTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.EventSource, this.options.withCredentials!, this.options.headers || {});\n            case HttpTransportType.LongPolling:\n                return new LongPollingTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.withCredentials!, this.options.headers || {});\n            default:\n                throw new Error(`Unknown transport: ${transport}.`);\n        }\n    }\n\n    private startTransport(url: string, transferFormat: TransferFormat): Promise<void> {\n        this.transport!.onreceive = this.onreceive;\n        this.transport!.onclose = (e) => this.stopConnection(e);\n        return this.transport!.connect(url, transferFormat);\n    }\n\n    private resolveTransportOrError(endpoint: IAvailableTransport, requestedTransport: HttpTransportType | undefined, requestedTransferFormat: TransferFormat): ITransport | Error {\n        const transport = HttpTransportType[endpoint.transport];\n        if (transport === null || transport === undefined) {\n            this.logger.log(LogLevel.Debug, `Skipping transport '${endpoint.transport}' because it is not supported by this client.`);\n            return new Error(`Skipping transport '${endpoint.transport}' because it is not supported by this client.`);\n        } else {\n            if (transportMatches(requestedTransport, transport)) {\n                const transferFormats = endpoint.transferFormats.map((s) => TransferFormat[s]);\n                if (transferFormats.indexOf(requestedTransferFormat) >= 0) {\n                    if ((transport === HttpTransportType.WebSockets && !this.options.WebSocket) ||\n                        (transport === HttpTransportType.ServerSentEvents && !this.options.EventSource)) {\n                        this.logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it is not supported in your environment.'`);\n                        return new Error(`'${HttpTransportType[transport]}' is not supported in your environment.`);\n                    } else {\n                        this.logger.log(LogLevel.Debug, `Selecting transport '${HttpTransportType[transport]}'.`);\n                        try {\n                            return this.constructTransport(transport);\n                        } catch (ex) {\n                            return ex;\n                        }\n                    }\n                } else {\n                    this.logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it does not support the requested transfer format '${TransferFormat[requestedTransferFormat]}'.`);\n                    return new Error(`'${HttpTransportType[transport]}' does not support ${TransferFormat[requestedTransferFormat]}.`);\n                }\n            } else {\n                this.logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it was disabled by the client.`);\n                return new Error(`'${HttpTransportType[transport]}' is disabled by the client.`);\n            }\n        }\n    }\n\n    private isITransport(transport: any): transport is ITransport {\n        return transport && typeof (transport) === \"object\" && \"connect\" in transport;\n    }\n\n    private stopConnection(error?: Error): void {\n        this.logger.log(LogLevel.Debug, `HttpConnection.stopConnection(${error}) called while in state ${this.connectionState}.`);\n\n        this.transport = undefined;\n\n        // If we have a stopError, it takes precedence over the error from the transport\n        error = this.stopError || error;\n        this.stopError = undefined;\n\n        if (this.connectionState === ConnectionState.Disconnected) {\n            this.logger.log(LogLevel.Debug, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection is already in the disconnected state.`);\n            return;\n        }\n\n        if (this.connectionState === ConnectionState.Connecting) {\n            this.logger.log(LogLevel.Warning, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection is still in the connecting state.`);\n            throw new Error(`HttpConnection.stopConnection(${error}) was called while the connection is still in the connecting state.`);\n        }\n\n        if (this.connectionState === ConnectionState.Disconnecting) {\n            // A call to stop() induced this call to stopConnection and needs to be completed.\n            // Any stop() awaiters will be scheduled to continue after the onclose callback fires.\n            this.stopPromiseResolver();\n        }\n\n        if (error) {\n            this.logger.log(LogLevel.Error, `Connection disconnected with error '${error}'.`);\n        } else {\n            this.logger.log(LogLevel.Information, \"Connection disconnected.\");\n        }\n\n        if (this.sendQueue) {\n            this.sendQueue.stop().catch((e) => {\n                this.logger.log(LogLevel.Error, `TransportSendQueue.stop() threw error '${e}'.`);\n            });\n            this.sendQueue = undefined;\n        }\n\n        this.connectionId = undefined;\n        this.connectionState = ConnectionState.Disconnected;\n\n        if (this.connectionStarted) {\n            this.connectionStarted = false;\n            try {\n                if (this.onclose) {\n                    this.onclose(error);\n                }\n            } catch (e) {\n                this.logger.log(LogLevel.Error, `HttpConnection.onclose(${error}) threw error '${e}'.`);\n            }\n        }\n    }\n\n    private resolveUrl(url: string): string {\n        // startsWith is not supported in IE\n        if (url.lastIndexOf(\"https://\", 0) === 0 || url.lastIndexOf(\"http://\", 0) === 0) {\n            return url;\n        }\n\n        if (!Platform.isBrowser || !window.document) {\n            throw new Error(`Cannot resolve '${url}'.`);\n        }\n\n        // Setting the url to the href propery of an anchor tag handles normalization\n        // for us. There are 3 main cases.\n        // 1. Relative path normalization e.g \"b\" -> \"http://localhost:5000/a/b\"\n        // 2. Absolute path normalization e.g \"/a/b\" -> \"http://localhost:5000/a/b\"\n        // 3. Networkpath reference normalization e.g \"//localhost:5000/a/b\" -> \"http://localhost:5000/a/b\"\n        const aTag = window.document.createElement(\"a\");\n        aTag.href = url;\n\n        this.logger.log(LogLevel.Information, `Normalizing '${url}' to '${aTag.href}'.`);\n        return aTag.href;\n    }\n\n    private resolveNegotiateUrl(url: string): string {\n        const index = url.indexOf(\"?\");\n        let negotiateUrl = url.substring(0, index === -1 ? url.length : index);\n        if (negotiateUrl[negotiateUrl.length - 1] !== \"/\") {\n            negotiateUrl += \"/\";\n        }\n        negotiateUrl += \"negotiate\";\n        negotiateUrl += index === -1 ? \"\" : url.substring(index);\n\n        if (negotiateUrl.indexOf(\"negotiateVersion\") === -1) {\n            negotiateUrl += index === -1 ? \"?\" : \"&\";\n            negotiateUrl += \"negotiateVersion=\" + this.negotiateVersion;\n        }\n        return negotiateUrl;\n    }\n}\n\nfunction transportMatches(requestedTransport: HttpTransportType | undefined, actualTransport: HttpTransportType) {\n    return !requestedTransport || ((actualTransport & requestedTransport) !== 0);\n}\n\n/** @private */\nexport class TransportSendQueue {\n    private buffer: any[] = [];\n    private sendBufferedData: PromiseSource;\n    private executing: boolean = true;\n    private transportResult?: PromiseSource;\n    private sendLoopPromise: Promise<void>;\n\n    constructor(private readonly transport: ITransport) {\n        this.sendBufferedData = new PromiseSource();\n        this.transportResult = new PromiseSource();\n\n        this.sendLoopPromise = this.sendLoop();\n    }\n\n    public send(data: string | ArrayBuffer): Promise<void> {\n        this.bufferData(data);\n        if (!this.transportResult) {\n            this.transportResult = new PromiseSource();\n        }\n        return this.transportResult.promise;\n    }\n\n    public stop(): Promise<void> {\n        this.executing = false;\n        this.sendBufferedData.resolve();\n        return this.sendLoopPromise;\n    }\n\n    private bufferData(data: string | ArrayBuffer): void {\n        if (this.buffer.length && typeof(this.buffer[0]) !== typeof(data)) {\n            throw new Error(`Expected data to be of type ${typeof(this.buffer)} but was of type ${typeof(data)}`);\n        }\n\n        this.buffer.push(data);\n        this.sendBufferedData.resolve();\n    }\n\n    private async sendLoop(): Promise<void> {\n        while (true) {\n            await this.sendBufferedData.promise;\n\n            if (!this.executing) {\n                if (this.transportResult) {\n                    this.transportResult.reject(\"Connection stopped.\");\n                }\n\n                break;\n            }\n\n            this.sendBufferedData = new PromiseSource();\n\n            const transportResult = this.transportResult!;\n            this.transportResult = undefined;\n\n            const data = typeof(this.buffer[0]) === \"string\" ?\n                this.buffer.join(\"\") :\n                TransportSendQueue.concatBuffers(this.buffer);\n\n            this.buffer.length = 0;\n\n            try {\n                await this.transport.send(data);\n                transportResult.resolve();\n            } catch (error) {\n                transportResult.reject(error);\n            }\n        }\n    }\n\n    private static concatBuffers(arrayBuffers: ArrayBuffer[]): ArrayBuffer {\n        const totalLength = arrayBuffers.map((b) => b.byteLength).reduce((a, b) => a + b);\n        const result = new Uint8Array(totalLength);\n        let offset = 0;\n        for (const item of arrayBuffers) {\n            result.set(new Uint8Array(item), offset);\n            offset += item.byteLength;\n        }\n\n        return result.buffer;\n    }\n}\n\nclass PromiseSource {\n    private resolver?: () => void;\n    private rejecter!: (reason?: any) => void;\n    public promise: Promise<void>;\n\n    constructor() {\n        this.promise = new Promise((resolve, reject) => [this.resolver, this.rejecter] = [resolve, reject]);\n    }\n\n    public resolve(): void {\n        this.resolver!();\n    }\n\n    public reject(reason?: any): void {\n        this.rejecter!(reason);\n    }\n}\n"]}