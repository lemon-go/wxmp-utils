{"version":3,"file":"WebSocketTransport.js","sourceRoot":"","sources":["../../src/WebSocketTransport.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\n\nimport { HttpClient } from \"./HttpClient\";\nimport { MessageHeaders } from \"./IHubProtocol\";\nimport { ILogger, LogLevel } from \"./ILogger\";\nimport { ITransport, TransferFormat } from \"./ITransport\";\nimport { WebSocketConstructor } from \"./Polyfills\";\nimport { Arg, getDataDetail, getUserAgentHeader, Platform } from \"./Utils\";\n\n/** @private */\nexport class WebSocketTransport implements ITransport {\n    private readonly logger: ILogger;\n    private readonly accessTokenFactory: (() => string | Promise<string>) | undefined;\n    private readonly logMessageContent: boolean;\n    private readonly webSocketConstructor: WebSocketConstructor;\n    private readonly httpClient: HttpClient;\n    private webSocket?: WebSocket;\n    private headers: MessageHeaders;\n\n    public onreceive: ((data: string | ArrayBuffer) => void) | null;\n    public onclose: ((error?: Error) => void) | null;\n\n    constructor(httpClient: HttpClient, accessTokenFactory: (() => string | Promise<string>) | undefined, logger: ILogger,\n                logMessageContent: boolean, webSocketConstructor: WebSocketConstructor, headers: MessageHeaders) {\n        this.logger = logger;\n        this.accessTokenFactory = accessTokenFactory;\n        this.logMessageContent = logMessageContent;\n        this.webSocketConstructor = webSocketConstructor;\n        this.httpClient = httpClient;\n\n        this.onreceive = null;\n        this.onclose = null;\n        this.headers = headers;\n    }\n\n    public async connect(url: string, transferFormat: TransferFormat): Promise<void> {\n        Arg.isRequired(url, \"url\");\n        Arg.isRequired(transferFormat, \"transferFormat\");\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\n        this.logger.log(LogLevel.Trace, \"(WebSockets transport) Connecting.\");\n\n        if (this.accessTokenFactory) {\n            const token = await this.accessTokenFactory();\n            if (token) {\n                url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(token)}`;\n            }\n        }\n\n        return new Promise<void>((resolve, reject) => {\n            url = url.replace(/^http/, \"ws\");\n            let webSocket: WebSocket | undefined;\n            const cookies = this.httpClient.getCookieString(url);\n            let opened = false;\n\n            if (Platform.isUni || Platform.isWechatMP) {\n                webSocket = new this.webSocketConstructor(url, undefined, {\n                    headers: this.headers,\n                });\n            } else if (Platform.isNode) {\n                const headers = {};\n                const [name, value] = getUserAgentHeader();\n                headers[name] = value;\n\n                if (cookies) {\n                    headers[`Cookie`] = `${cookies}`;\n                }\n\n                // Only pass headers when in non-browser environments\n                webSocket = new this.webSocketConstructor(url, undefined, {\n                    headers: { ...headers, ...this.headers },\n                });\n            }\n\n            if (!webSocket) {\n                // Chrome is not happy with passing 'undefined' as protocol\n                webSocket = new this.webSocketConstructor(url);\n            }\n\n            if (transferFormat === TransferFormat.Binary) {\n                webSocket.binaryType = \"arraybuffer\";\n            }\n\n            // tslint:disable-next-line:variable-name\n            webSocket.onopen = (_event: Event) => {\n                this.logger.log(LogLevel.Information, `WebSocket connected to ${url}.`);\n                this.webSocket = webSocket;\n                opened = true;\n                resolve();\n            };\n\n            webSocket.onerror = (event: Event) => {\n                let error: any = null;\n                // ErrorEvent is a browser only type we need to check if the type exists before using it\n                if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\n                    error = event.error;\n                } else {\n                    error = new Error(\"There was an error with the transport.\");\n                }\n\n                reject(error);\n            };\n\n            webSocket.onmessage = (message: MessageEvent) => {\n                this.logger.log(LogLevel.Trace, `(WebSockets transport) data received. ${getDataDetail(message.data, this.logMessageContent)}.`);\n                if (this.onreceive) {\n                    try {\n                        this.onreceive(message.data);\n                    } catch (error) {\n                        this.close(error as Error);\n                        return;\n                    }\n                }\n            };\n\n            webSocket.onclose = (event: CloseEvent) => {\n                // Don't call close handler if connection was never established\n                // We'll reject the connect call instead\n                if (opened) {\n                    this.close(event);\n                } else {\n                    let error: any = null;\n                    // ErrorEvent is a browser only type we need to check if the type exists before using it\n                    if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\n                        error = event.error;\n                    } else {\n                        error = new Error(\"There was an error with the transport.\");\n                    }\n\n                    reject(error);\n                }\n            };\n        });\n    }\n\n    public send(data: any): Promise<void> {\n        if (this.webSocket && this.webSocket.readyState === this.webSocketConstructor.OPEN) {\n            this.logger.log(LogLevel.Trace, `(WebSockets transport) sending data. ${getDataDetail(data, this.logMessageContent)}.`);\n            this.webSocket.send(data);\n            return Promise.resolve();\n        }\n\n        return Promise.reject(\"WebSocket is not in the OPEN state\");\n    }\n\n    public stop(): Promise<void> {\n        if (this.webSocket) {\n            // Manually invoke onclose callback inline so we know the HttpConnection was closed properly before returning\n            // This also solves an issue where websocket.onclose could take 18+ seconds to trigger during network disconnects\n            this.close(undefined);\n        }\n\n        return Promise.resolve();\n    }\n\n    private close(event?: CloseEvent | Error): void {\n        // webSocket will be null if the transport did not start successfully\n        if (this.webSocket) {\n            // Clear websocket handlers because we are considering the socket closed now\n            this.webSocket.onclose = () => {};\n            this.webSocket.onmessage = () => {};\n            this.webSocket.onerror = () => {};\n            this.webSocket.close();\n            this.webSocket = undefined;\n        }\n\n        this.logger.log(LogLevel.Trace, \"(WebSockets transport) socket closed.\");\n        if (this.onclose) {\n            if (this.isCloseEvent(event) && (event.wasClean === false || event.code !== 1000)) {\n                this.onclose(new Error(`WebSocket closed with status code: ${event.code} (${event.reason}).`));\n            } else if (event instanceof Error) {\n                this.onclose(event);\n            } else {\n                this.onclose();\n            }\n        }\n    }\n\n    private isCloseEvent(event?: any): event is CloseEvent {\n        return event && typeof event.wasClean === \"boolean\" && typeof event.code === \"number\";\n    }\n}\n"]}